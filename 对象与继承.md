1. 对象的定义：“无序属性的集合，其属性可以包括基础值、对象或者函数”;
1. 对象的属性类型
    我了实现javascript引擎使用，只有内部才用的特性，描述了各种特征。为了表示特性是内部值，把他们放在两对方括号内。
 分两种属性
1、数据属性：包含一个数据值的位置。在那个位置可以读取和写入值
1. -     [[Configurable]]: 表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。直接在对象上定义的属性，默认值是true。
2. -     [[Enumerable]]: 表示能否通过for-in循环返回属性。默认是true。
3. -     [[Writable]]: 表示能否修改属性的值。默认是true。
4. -     [[Value]]: 包括这个属性的数据值。读取属性值的时候，从这个位置读；写入属性值的时候，把新值保存在那个位置。默认值为undefined

```
如果需要修改属性默认的特性。必须使用es5的Object.defineProperty()方法。接受三个参数：属性所在的对象、属性的名字和一个描述符对象。描述符对象的属性必须是：configurable、enumeration、writeable、value。设置其中的一个或多个值，可以修改对应的特性值。
var person = {};
Object.defineProperty(person, "name", {
    writable: false,
    value: 'CHEN'
});
console.log(person.name);//CHEN
person.name = 'jin';
console.log(person.name);//CHEN

可以多次调用Object.defineProperty()方法修改同一个属性，但在把configurable特性设置为false之后就会有限制，不在让修改,使用的次方法，属性默认是false
```
2、访问器属性： 访问器属性不包括数据值；他们包含一对getter和setter函数。在读取访问器属性时，会调用getter函数。那个函数负责返回有效的值，在写入访问器属性时，会调用setter函数并传入新值，这个函数负责决定如何处理数据。访问器属性有4个特征
1. -     [[Configurable]]: 表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。直接在对象上定义的属性，默认值是true。
2. -     [[Enumerable]]: 表示能否通过for-in循环返回属性。默认是true。
3. -     [[Get]]: 在读取属性时调动的函数。默认值为undefined
4. -     [[Set]]: 在写入属性时调用的函数。默认值为undefined

```
Object.defineProperty(book, "year", {
    get: function () {
        return this._year;
    },
    set: function (newValue) {
        if (newValue > 2004) {
            this._year = newValue;
            this.edition += newValue - 2004;
        }
    }
})

book.year = 2019;
console.log(book);//{ _year: 2019, edition: 16 }
```
3、定义多个属性：在es5中使用Object.defineProperties()方法。可以通过描述符一次定义多个属性。
```
Object.defineProperties(books, {
    _year: {
        value: 2004
    },

    edition: {
        value: 1
    },
    year: {
        get: function() {
            return this._year;
        },

        set: function (newValue) {
            if(newValue > 2004) {
                this._year = newValue;
                this.edition += newValue - 2004;
            }
        }
    }
})
```

4、读取属性的特性
在es5中Object.getOwnPropertyDescriptor()方法。可以读取得给定属性的描述符。属性所在的队形和要读取其描述符的属性名称。返回一个对象。如果是访问器属性。对象的属性有configurable、enumerable、get、set；如果是数据属性，那个对象的属性有、configurable、enumerable、writable和value。
```
var descriptor = Object.getOwnPropertyDescriptor(book, "_year");
console.log(descriptor);
{ value: 2004,
  writable: true,
  enumerable: true,
  configurable: true }

var descriptor = Object.getOwnPropertyDescriptor(books, "_year");
console.log(descriptor);

{ value: 2004,
  writable: false,
  enumerable: false,
  configurable: false }
var descriptor = Object.getOwnPropertyDescriptor(books, "year");
console.log(descriptor);
var descriptor = Object.getOwnPropertyDescriptor(books, "year");
console.log(descriptor);
{ get: [Function: get],
  set: [Function: set],
  enumerable: false,
  configurable: false }
{ get: [Function: get],
  set: [Function: set],
  enumerable: false,
  configurable: false }
```

5、创建对象
使用构造函数来创建对象。使用构造函数是必须使用new操作符。过啊走啊函数经历了以下4步：
（1）创建一个新对象
（2）将构造函数的作用域赋给新对象(因此this就指向了那个新对象)；
（3）执行构造函数中的代码（为那个新对象添加属性）；
（4）返回新对象;

person1是Person的一个的实例。每个不同的实例都有一个constructor（构造函数）属性。该属性指向Person
``` 
console.log(person1.constructor == Person)  //true
```

检测对象类型使用instanceof（ 判断对象类型）

```
console.log(person1 instanceof Object);
console.log(person1 instanceof Person);
```
6、原型模式
    我们创建的每个函数都有一个prototype（原型）属性。那个属性是一个指针，指向一个对象（原型对象），对象的用途是包含可以由特定类型的所有实例共享的属性和方法。
    prototype就是通过调用构造函数而创建的那个对象实例的原型对象。使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法。
    1、理解原型对象
        每当我们创建一个新函数。就会为该函数创建一个prototype属性，这个属性指向函数的原型对象。在默认的详情下。所有原型对象都会自动获得一个constructor(构造函数)属性。那个属性包含一个指向prototype属性所在函数的指针。通过那个构造函数为原型对象添加其他属性和方法。
```
Person.prototype.constructor ==  Person
当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（内部属性），指向构造函数的原型对象。那个指针叫[[Prototype]]__proto__;
```
       
       
       
       
 ![image](http://oh14ph22t.bkt.clouddn.com/propertype.jpg)



 可以同isPrototyoeof() 方法来确定对象之间是否存在那种关系。isPrototypeOf()函数用于指示对象是否存在于另一个对象的原型链中。如果存在，返回true，否则返回false。
 ```
 console.log(Person.prototype.isPrototypeOf(person1)//true
 ```


在es5中Object.getPrototypeOf(),返回[[Prototype]]的值。

```
console.log(Object.getPrototypeOf(person1) == Person.prototype);
console.log(Object.getPrototypeOf(person1).name);
```

7、in与hasOwnProperty的区别

in操作符只要通过对象能够访问到属性就会返回true，hasOwnProperty()只在属性存在于实例时才返回true

8、keys与getOwnPropertyNames的区别

keys可以去到key ，另外一个可以去到包括constructor在内的所有属性。
```
function Per(){

}

Per.prototype = {
    constructor: Per,
    name: 'chen',
    age: '29',
    job: 'sss'
};
当使用对象写prototype时，需要修正constructor，不修正指向了Object
```


实例中的指针仅指向原型，而不指向构造函数
